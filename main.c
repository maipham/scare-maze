#include "gba.h"
#include "win.h"
#include "dot.h"
#include "playGround.h"
#include "over.h"
#include "welcome.h"
#include "rules.h"
#include "fail.h"
#include <string.h>

// TA-TODO: Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage

#include <stdio.h>
#include <stdlib.h>

extern const unsigned short fail[38400];
extern const unsigned short win[38400];
extern const unsigned short welcome[38400];
extern const unsigned short rules[38400];
extern const unsigned short playGround[38400];
extern const unsigned short dot[625];
extern const unsigned short over[38400];

// AppState enum definition
typedef enum {
    // TA-TODO: Add any additional states you need for your app.
    START,
    START_NODRAW,
    RULES,
    BEFORE_PLAY,
    PLAY,
    GAME_OVER,
    WIN,
    SCARE,
} GBAState;

// Use this struct to keep track of dot position in the game.
typedef struct {
    int row;
    int col;
} DotPosition;

// Use this struct to initialize the top left coordinates.
typedef struct {
    int x;
    int y;
} Origin;

// Directions to navigate in the game.
typedef enum {
    UP,
    DOWN,
    LEFT,
    RIGHT,
} Direction;

const int dot_width = 3;  // width of the dot
const int dot_height = 3;  // height of the dot

// Functions for the game.
void dotSpeed(Direction direction);
void moveDot(Direction direction);
int hitWall(void);
int finish(void);
void resetGame(void);

u16 wall = 0x673f;  // color of the walls to check for collisions
u16 finishLine = 0x2ac0;  // color of the finish line check for winning
u16 textColor = 0x6a6b;

Direction currentDirection = RIGHT; 
DotPosition dotPos = {134, 19}; 
Origin topleft = {0, 0};

int playGround_inited = 0;
int scare = 1;
int done = 1;
int notDrawRules = 1;
int speed = 6000;
int bestScore = 0;

GBAState state = START;

int main(void) {
    // TA-TODO: Manipulate REG_DISPCNT here to set Mode 3.
    REG_DISPCNT = MODE3 | BG2_ENABLE;

    while(1) {
        switch(state) {
        case START:
            // Wait for VBlank
            waitForVBlank();

            // TA-TODO: Draw the start state here
            drawFullScreenImageDMA(welcome);
	        drawString(65, 80, "press ENTER to start", textColor);

            state = START_NODRAW;
            break;
        case START_NODRAW:
            if (KEY_PRESSED(BUTTON_START)) {
                state = RULES;
            }
            break;
        case RULES:
            // If the rules have not drawn, then draw the rules, prevent redrawing
            if (notDrawRules) {
                notDrawRules = 0;
                drawFullScreenImageDMA(rules);
                drawString(20, 60, "- Use arrow keys to navigate", textColor);
                drawString(20, 70, "  around the maze", textColor);
                drawString(20, 85, "- To move fast hold down", textColor);
                drawString(20, 95, "  the arrow key", textColor);
                drawString(20, 115, "- DO NOT hit the walls", textColor);
                drawString(20, 130, "- Press BACKSPACE to play", textColor);
            }
            if (KEY_PRESSED(BUTTON_SELECT)) {
                state = BEFORE_PLAY;
            }
            break;
        case BEFORE_PLAY:
            // If the playground has not been inited, then init, prevent redrawing
            if (!playGround_inited) {
                drawFullScreenImageDMA(playGround);
                drawRectDMA(dotPos.row, dotPos.col, dot_width, dot_height, RED);
                drawString(15, 148, "press -> to start", textColor);
                playGround_inited = 1;
            }
            if (KEY_PRESSED(BUTTON_RIGHT)) {
                state = PLAY;
            }
            break;
        case PLAY:
            // Speed of the dot 
            if (speed < 0) {
                // Wait for VBlank before we do any drawing.
                waitForVBlank();
                undrawDMA(playGround);
                moveDot(currentDirection);
                if (hitWall()) {
                    state = SCARE;
                }
                if (finish()) {
                    state = WIN;
                }
                drawRectDMA(dotPos.row, dotPos.col, dot_width, dot_height, RED);
                if (KEY_PRESSED(BUTTON_DOWN)) { moveDot(DOWN); currentDirection = DOWN; }
                if (KEY_PRESSED(BUTTON_UP)) { moveDot(UP); currentDirection = UP; }
                if (KEY_PRESSED(BUTTON_LEFT)) { moveDot(LEFT); currentDirection = LEFT; }
                if (KEY_PRESSED(BUTTON_RIGHT)) { moveDot(RIGHT); currentDirection = RIGHT; }
                speed = 6000;
            } else {
                speed--;
            }
            break;
        case WIN:
            if (done) {
                drawFullScreenImageDMA(win);
                drawString(35, 110, "press BACKSPACE to play again", textColor);
                done = 0;
            }

            if (KEY_PRESSED(BUTTON_SELECT)) {
                resetGame();
            }
            break;
        case SCARE:
            if (scare) {
                drawFullScreenImageDMA(fail);
                drawString(20, 10, "press ENTER", WHITE);
                scare = 0;
            }
            if (KEY_PRESSED(BUTTON_START)) {
                state = GAME_OVER;
            }
            break;
        case GAME_OVER:
            if (done) {
                drawFullScreenImageDMA(over);
                drawString(35, 110, "press BACKSPACE to play again", textColor);
                done = 0;
            }

            if (KEY_PRESSED(BUTTON_SELECT)) {
                resetGame();
            }
            break;
        }
    }
    return 0;
}

// Reset the game for a new play
void resetGame(void) {
    state = START;
    playGround_inited = 0;
    scare = 1;
    speed = 6000;
    currentDirection = RIGHT;
    dotPos.row = 134;
    dotPos.col = 19;
    notDrawRules = 1;
    done = 1;
}

// Check if a collision occurs
int hitWall(void) {
    if (videoBuffer[dotPos.col + WIDTH * dotPos.row] == wall) {
        return 1;
    }
    if (videoBuffer[(dotPos.col + 2) + WIDTH * (dotPos.row + 2)] == wall) {
	return 1;
    }
    if (videoBuffer[(dotPos.col + 2) + WIDTH * dotPos.row] == wall) {
	return 1;
    }
    if (videoBuffer[dotPos.col + WIDTH * (dotPos.row + 2)] == wall) {
	return 1;
    }
    return 0;
}

// Check if the dot has reached the finish line
int finish(void) {
    if (videoBuffer[dotPos.col + WIDTH * dotPos.row] == finishLine) {
        return 1;
    }
    return 0;
}

// Move the dot in the chosen direction
void moveDot(Direction direction) {
    switch(direction) {
        case UP:
            dotPos.row--;
            break;
        case DOWN:
            dotPos.row++;
            break;
        case LEFT:
            dotPos.col--;
            break;
        case RIGHT:
            dotPos.col++;
            break;
    }
}
